#version 430

struct Triangle {
  uint index0;
  uint index1;
  uint index2;
  uint material_index;
};

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D u_OutputImage;

layout(std430, binding = 0) buffer material_buffer {
  vec3 materials[];
};

layout(std430, binding = 1) buffer vertex_buffer {
  vec3 vertices[];
};

layout(std430, binding = 2) buffer triangle_buffer {
  Triangle triangles[];
};

uniform vec3 u_Right;
uniform vec3 u_Up;
uniform vec3 u_Forward;
uniform vec3 u_CameraPosition;
uniform uint u_TriangleCount;

bool IntersectTriangle(vec3 ray_origin, vec3 ray_direction, vec3 p0, vec3 p1, vec3 p2,
                       out float hit, out vec3 barycentricCoord, out vec3 triangleNormal)
{
    const vec3 e0 = p1 - p0;
    const vec3 e1 = p0 - p2;
    triangleNormal = cross( e1, e0 );

    const vec3 e2 = ( 1.0 / dot( triangleNormal, ray_direction ) ) * ( p0 - ray_origin );
    const vec3 i  = cross( ray_direction, e2 );

    barycentricCoord.y = dot( i, e1 );
    barycentricCoord.z = dot( i, e0 );
    barycentricCoord.x = 1.0 - (barycentricCoord.z + barycentricCoord.y);
    hit   = dot( triangleNormal, e2 );

    return  /*(hit < ray.tmax) && */ (hit > 0.0001) && all(greaterThanEqual(barycentricCoord, vec3(0.0)));
}

void main() {
  // Resolution of the output image
  vec2 resolution = vec2(gl_NumWorkGroups.xy);

  // Get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  // Color of the iamge
  vec4 pixel = vec4(0.0, 0.0, 0.0, 1.0);

  vec2 normalized = vec2(pixel_coords) / (resolution - vec2(1.0, 1.0)) - vec2(0.5, 0.5);
  vec3 view_direction = normalize(
    normalized.x * u_Right + 
    normalized.y * u_Up + 
                   u_Forward);

  float closest_hit = 1.0 / 0.0; // = infinity()
  for (uint i = 0; i < u_TriangleCount; ++i) {
    float hit;
    vec3 barycentric_coordinates;
    vec3 triangle_normal;
    if (IntersectTriangle(u_CameraPosition, view_direction,
          vertices[triangles[i].index0],
          vertices[triangles[i].index1],
          vertices[triangles[i].index2],
          hit, barycentric_coordinates, triangle_normal) &&
        hit < closest_hit) {
      closest_hit = hit;
      pixel.xyz = materials[triangles[i].material_index];
    }
  }
  
  //
  // interesting stuff happens here later
  //
  
  // output to a specific pixel in the image
  imageStore(u_OutputImage, pixel_coords, pixel);
}
